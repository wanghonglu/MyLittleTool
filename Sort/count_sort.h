#ifndef __COUNT_SORT__H
#define __COUNT_SORT__H
/*
 *  计数排序,跟基数排序同音不同名
 *      应用场景是整体数据差值比较小的情况 即最大值和最小值相差不大的情况
 *      简单来说就是 假如给定一组数据 0 7 2 8 1 2 3 9 10 6
 *
 *      最大不超过10 所以可以申请以11个字节的长度的数组,统计每个数字出现的次数
 *      count[0]=1 count[1]=1 count[2]=2 count[3]=1....
 *      然后输出这个计数数组,每个位置上有几个值就输出几个值 最终会得到
 *      0 1 2 2 3 ......
 *      
 *      这里要注意一点,就是如果只是用最大值作为计数数组的长度的话会有点问题,比如
 *      90 91 92 93 95 99 100 
 *      这几个数字 如果用长度位101的话 前面90 就都没用了,不太好,正确做法是 数组长度位 (max-min)+1
 *
 *      第二个问题
 *      因为上面输出的是计数数组的下标,这样的话,假如给定的条件是这样的
 *      张三 100
 *      李四 98
 *      赵五 97
 *      刘九 98
 *      这样的话 两个98,无法对应到原来的数组里面,分不清哪个是哪个
 *      类似基数排序的 count数组的处理,可以进行 count[i]+=count[i-1]
 *      放数据的时候就可以 result[--count[..]]=ptr[i]的操作了
 *      同样针对负数的处理,可以类似于基数操作,如果有负数 所有数-min 导致最小的是0  排序完了再+min
 *      时间复杂度计数数组遍历了两次 原数组找大小遍历了依次 入桶又依次 
 *      所以时间复杂度O(2m+2n) ~O(m+n) m为最大和最小的差值 n为总共的元素数
 *      空间复杂度也是O(m+n) 用了额外的两个数组
 * */
#ifdef __cplusplus
extern "C"{
#endif
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>
#include<string.h>
void
count_sort( int*ptr, int len );

#ifdef __cplusplus
}
#endif
#endif
