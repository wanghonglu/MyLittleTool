#ifndef __RADIX_SORT__H
#define __RADIX_SORT__H
/*
 *  基数排序:
 *          是一种基于非比较的排序方法
 *          大概原理是这样
 *          a[]=[9,28,312];
 *          加入对这三个数排序,首先最大的数是312即可以有 可以有10个桶(也可以有100 1000个桶 具体如果数据比较稀疏可以用比较大的桶) 从个位/十位...按从小到大排序 
 *          这里先说LSD(least significant digital ) 从低位开始 即从右边关键字开始 
 *          分成9在9号桶 28在8号桶 312在2号桶
 *          然后放到数组里面变成 312 28 9
 *          然后按照10位 9在0号桶 28在2号桶 312在1号桶
 *          然后放到数组里面 9 312 28
 *          然后再按百位 0号桶里有[9,28] 3号桶312
 *          取出来就变成 9 28 312 
 *          ascii码 可以用128个桶
 *          这里有一个地方需要注意 假如0号桶里面有8个数据 1号桶里面有2个数据
 *          那么排序的时候0号桶里 这个8个数据的下标是0-7 1号桶里的这两个数据的下标是 8-9,
 *          所以记数数组要做累加 a[i]+=a[i-1],即加入有4个数据a[]={10,1,22,20},记数数组c[0]=2 c[1]=1 c[2]=1
 *          b数组是结果数组,10应该放在0号位置 20放在1号位置 即 b[--c[0]]=a[1] b[--c[0]] = a[3]
 *          但是这里要用原数组a就行反向填充,不知道为什么非得反向? 先写着看看
 *
 *          这里可以大概算下时间复杂度,假设最大数是N的话,那么位数就是log以10为底N (比如100就是3 ..)那么时间复杂度就是(nlogMax)
 *          可以看到这个值并不一定比比较排序的 nlogn 就小
 *
 *          一趟排序之后 数组从头到尾是按照个位从小到大排序
 *          count[10] 数组里面存放的是每个位的数字的个数
 *          count[i]=count[i-1] 计算之后 可以通过对 --count[i]给每个数安排具体的下标
 *          即再次放数据的时候 是先放下标大的值,即先放后面再放前面
 *          所以第一次数据需要倒着遍历,保证放十位相同的数,先放个位大的
 *
 *          但是针对负数排序依然会有问题 因为负数不能简单的做数组下标
 *
 *          针对负数的处理方法是,找出最小的数,如果最小的数是负数,那么给所有的数-去这个负数
 *          这样原来最小的数就变成0 就可以用基数排序了,然后排序完了后再统一减去这个最小数即可
 *
 *          再说下 MSD( most significandt digital )
 *          MSD的原理跟LSD切好不同,是由键值的最左边开始 然后针对每个桶的数据,如果桶内数据超过1个就递归进行排序
 *          比如 原数组[12,4,567,542,400,918]
 *          第一次按照百位去划分10个桶,0号桶里面[12,4],4号桶[400],5号桶[567,542] 9号桶[918]
 *          这样将数据拷贝到结果数组里面,结果数组变成了[12,4,400,567,542,918]
 *          然后看各个桶剩余的数据,数据大于1 就在那个范文内递归调用再去分桶 直到桶内剩余一个数据
 *          这里找到边界的处理方法有意思 原来的计数数组里面 count[0]=2 count[1]=0 count[2]=0 count[3]=0 count[4]=1 count[5]=2 count[9]=1;
 *          因为要给具体的数安排到具体的下标里面 即12 4 分别是0 1下标 400则是2下边
 *          所以这里需要做的是 a[i]=a[i-1] count数组变成 count[0]=2 count[1]=2 count[2]=2 count[3]=2 count[4]=3 count[5]=5 ....count[9]=6;
 *          然后将数组放到结果数组里面后 放结果数组的时候 result[--count[0]] 
 *          放完之后 count[0]=0 count[1]=2 count[3]=2 count[4]=2  count[5]=3
 *          可以看到本身刚好是自己数组的左边界 count[i+1]刚好是自己数组的右边界
 *          比如 count[0] 的左边界:0 右边界:count[1]-1=1 ...
 *          所以可以重新加回去,再次调用递归  原理有点绕 多理解理解 负数的处理跟上面一致
 *
 *          举个例子:
 *              原来数组[12,334,4,114,119,234]
 *              按整数位分组后 形成新的数组
 *              [12,4,114,119,234,334]
 *              其中12 4 和 114 和119要分别调用递归再次拆分
 *              关键是边界的计算:
 *              统计桶内数量:  c[0]=2 c[1]=2 c[2]=1 c[3]=1
 *              根据数量换算出具体的下标: c[0]=2 c[1]=4 c[2]=5 c[3]=6 每个元素具体坐标是--c[idx]
 *              从这里看 装桶的收 先进去的数组 越在后面,所以要倒序遍历
 *              装桶之后的c数组
 *              c[0]=0 c[1]=2 c[2]=4 c[3]=5
 *              则c[0]的边界是0-1 c[1]的边界时2-3 c[2]的边界是4-4 c[3]的边界是5 5
 *              c[i]的边界 是[c[i],c[i+1]-1] 当i+1==数组边界时 c[i+1]替换成len-1
 *
 *              亲测 MSG的效率要高于LSD 但MSG的代码比LSD的要复杂一点
 *              空间复杂度O(n) 时间复杂度 O(k*n) 
 *              如果数据比较小 比如全部在1亿以内 MSD的速度是最快的
 * */
#ifdef __cplusplus
extern "C"{
#endif
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<stdio.h>
#include<assert.h>
void
radix_sort_LSD(int*ptr, int len );
void
radix_sort_MSD(int*ptr, int len );
void
_radix_sort_MSD_recursive( int*ptr, int start, int end, int exp );

#ifdef __cplusplus
}
#endif


#endif
