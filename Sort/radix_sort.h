#ifndef __RADIX_SORT__H
#define __RADIX_SORT__H
/*
 *  基数排序:
 *          是一种基于非比较的排序方法
 *          大概原理是这样
 *          a[]=[9,28,312];
 *          加入对这三个数排序,首先最大的数是312即可以有 可以有10个桶 从个位/十位...按从小到大排序 
 *          这里先说LSD 从低位开始 即从右边关键字开始 
 *          分成9在9号桶 28在8号桶 312在2号桶
 *          然后放到数组里面变成 312 28 9
 *          然后按照10位 9在0号桶 28在2号桶 312在1号桶
 *          然后放到数组里面 9 312 28
 *          然后再按百位 0号位9  28 3号桶312
 *          取出来就变成 9 28 312 
 *          ascii码 可以用128个桶
 *          这里有一个地方需要注意 加入0号桶里面有8个数据 1号桶里面有2个数据
 *          那么排序的时候0号桶里 这个8个数据的下标是0-7 1号桶里的这两个数据的下标是 8-9,
 *          所以记数数组要做累加 a[i]+=a[i-1],即加入有4个数据a[]={10,1,22,20},记数数组c[0]=2 c[1]=1 c[2]=1
 *          b数组是结果数组,10应该放在0号位置 20放在1号位置 即 b[--c[0]]=a[1] b[--c[0]] = a[3]
 *          但是这里要用原数组a就行反向填充,不知道为什么非得反向? 先写着看看
 * */
#ifdef __cplusplus
extern "C"{
#endif
#include<stdio.h>
#include<assert.h>
#include<string.h>
#include<stdlib.h>
void
radix_sort_LSD(int*ptr, int len );
void
radix_sort_MDS(int*ptr, int len );

#ifdef __cplusplus
}
#endif


#endif
