#ifndef __HEAP_SORT_H
#define __HEAP_SORT_H

#ifdef __cplusplus
extern "C"{
#endif
/*
 *  堆排序:  是一种继续比较的排序算法,可以简单的认为它是选择排序的优化版,跟选择排序一样,都有以排序队列和未排序队列
 *  通过提取未排序队列的最大(最小)放在以排序队列中,来实现排序
 *  如果是从小大大排序,构建最大堆,取出堆顶,放在数组末尾,堆个数-1 从新调整最大堆,再次提取堆顶....
 *
 *  二叉堆,是一个完全二叉树,即除了最后一层,其他层都是满的即 
 *  除了最后一层其他层(k层)的节点数都达到了2(k-1)个,且最后一层的节点都在最左边
 *  因为它是完全二叉树,可以用数组来实现,方便所以其父节点
 *  二叉堆 以前写过 每次push 是吧新加入的元素放在最后 然后上浮 上浮稍微简单点,就跟父节点比较,比父节点大(最大堆)就交换
 *  每次pop是用最后的元素替换堆顶,然后下沉
 *  下沉需要选出两个孩子中最大(最大堆)或者最小(最小堆) 然后替换父节点 不停的下沉
 *
 *  现在要做的是数组堆化 肯定不能建立一个堆然后把数据放进去,需要原地建堆
 *  原始数组,我们假定a[0]即堆顶,调整堆,叶子节点是不用调整的,堆的特性是父节点大于(或小于)子节点
 *  所以我们需要调整每一个父节点,父节点做下沉操作,直到所有节点有符合堆特性
 *
 *  
 *  符合堆特性后,取出堆顶 放在以排序队列(从最后开始放,所以最大堆排序结果就是 从小到大 )
 *  然后把最后的元素放到堆顶,再次调整堆,回到上一步,直至最后一个堆里面剩最后一个元素
 *
 *  一个数组建堆的效果   
 *              10
 *          8        9
 *      7      6  5
 *  数组表示是a[]={10,8,9,7,6,5}
 *
 *  现在我们需要从最后一个有子节点的节点开始调整 数组长度为len的话
 *  最后一个元素的下标是 len-1
 *  那么他的父节点是 ((len-1)-1)/2 = len/2 - 1;
 *  如果某个节点的数组下标是n,那么他的左孩子节点是 2n+1 右孩子节点是2n+2 父节点的数组下标是 (n-1)/2
 *  第二个父节点依次-1即可
 *  可以递归 但不建议递归 循环即可
 *
 *  建堆的复杂度为O(n) 堆排序复杂对为O(logn) 所以总共的复杂度为 O(nlogn) 感觉跟快排差不多
 *  但是因为快排是相邻元素比较的 而堆排序是跳着比较的,对cpu缓存不太好 
 *  而且堆排序交换的次数比快排多
 *
 * */
#include<stdio.h>
void
heap_sort( int*ptr, int len );
/*
 *  pos 父节点坐标 待调整的数组下标
 * */
void
heap_shift_down(int*ptr, int len, int pos );

#ifdef __cplusplus
}
#endif
#endif
